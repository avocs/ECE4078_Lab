# evaluate the map generated by SLAM against the true map
# NOTE: call this file exactly like how you would call slam_eval.py, just change slam_eval.py to this file name
# see the main function to understand how to call this file 

import ast
import json
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider

def parse_map(fname : str) -> dict:
    with open(fname, 'r') as f:
        try:
            map = json.load(f)                   
        except ValueError as e:
            with open(fname, 'r') as f:
                map = ast.literal_eval(f.readline()) 
        
        aruco_dict = {}
        for key in map:
            if key.startswith("aruco"):
                aruco_num = int(key.strip('aruco')[:-2])
                aruco_dict[aruco_num] = np.reshape([map[key]["x"], map[key]["y"]], (2,1))

        print(aruco_dict)
    return aruco_dict

def save_map(fname1="lab_output/slam_transformed.txt", fname2="lab_output/objects.txt", fname3="newmap.txt"):

    with open(fname1, 'r') as f:
        try:
            map = json.load(f)                   
        except ValueError as e:
            with open(fname1, 'r') as f:
                map = ast.literal_eval(f.readline()) 
    d = {}
    for key in map:
        d[key] = map[key]

    with open(fname2, 'r') as f:
        try:
            map = json.load(f)                   
        except ValueError as e:
            with open(fname2, 'r') as f:
                map = ast.literal_eval(f.readline()) 
    # d = {}
    for key in map:
        d[key] = map[key]
    
        
    with open(fname3, 'w') as f3:
        json.dump(d, f3, indent=4)
    

# def parse_user_map(fname : str) -> dict:
    # with open(fname, 'r') as f:
        # try:
            # usr_dict = json.load(f)                   
        # except ValueError as e:
            # with open(fname, 'r') as f:
                # usr_dict = ast.literal_eval(f.readline()) 
        # aruco_dict = {}
        # for (i, tag) in enumerate(usr_dict["taglist"]):
            # aruco_dict[tag] = np.reshape([usr_dict["map"][0][i],usr_dict["map"][1][i]], (2,1))
    # return aruco_dict

def match_aruco_points(aruco0 : dict, aruco1 : dict):
    points0 = []
    points1 = []
    keys = []
    for key in aruco0:
        if not key in aruco1:
            continue
        
        points0.append(aruco0[key])
        points1.append(aruco1[key])
        keys.append(key)
    return keys, np.hstack(points0), np.hstack(points1)

def solve_umeyama2d(points1, points2):
    # Solve the optimal transform such that
    # R(theta) * p1_i + t = p2_i

    assert(points1.shape[0] == 2)
    assert(points1.shape[0] == points2.shape[0])
    assert(points1.shape[1] == points2.shape[1])


    # Compute relevant variables
    num_points = points1.shape[1]
    mu1 = 1/num_points * np.reshape(np.sum(points1, axis=1),(2,-1))
    mu2 = 1/num_points * np.reshape(np.sum(points2, axis=1),(2,-1))
    sig1sq = 1/num_points * np.sum((points1 - mu1)**2.0)
    sig2sq = 1/num_points * np.sum((points2 - mu2)**2.0)
    Sig12 = 1/num_points * (points2-mu2) @ (points1-mu1).T

    # Use the SVD for the rotation
    U, d, Vh = np.linalg.svd(Sig12)
    S = np.eye(2)
    if np.linalg.det(Sig12) < 0:
        S[-1,-1] = -1
    
    # Return the result as an angle and a 2x1 vector
    R = U @ S @ Vh
    theta = np.arctan2(R[1,0],R[0,0])
    x = mu2 - R @ mu1

    return theta, x

def apply_transform(theta, x, points):
    # Apply an SE(2) transform to a set of 2D points
    assert(points.shape[0] == 2)
    
    c, s = np.cos(theta), np.sin(theta)
    R = np.array(((c, -s), (s, c)))

    points_transformed =  R @ points + x
    return points_transformed


def compute_rmse(points1, points2):
    # Compute the RMSE between two matched sets of 2D points.
    assert(points1.shape[0] == 2)
    assert(points1.shape[0] == points2.shape[0])
    assert(points1.shape[1] == points2.shape[1])
    num_points = points1.shape[1]
    residual = (points1-points2).ravel()
    MSE = 1.0/num_points * np.sum(residual**2)

    return np.sqrt(MSE)



# NOTE this saves the transformed points into new slam.txt file 
def save_transformed_points(us_vec_aligned, fname='lab_output/slam_transformed.txt'):
    d = {}

    for i in range(len(taglist)):
        d["aruco" + str(taglist[i]) + "_0"] = {"x": us_vec_aligned[0,i], "y": us_vec_aligned[1,i]}
    
    with open(fname, 'w') as aligned_f:
        json.dump(d, aligned_f, indent=4)

    print(f"Transformed SLAM points saved as {fname}!")


#  NOTE here's the code for manual alignment
def manual_alignment(us_vec, gt_vec):
    """
    This function creates a Matplotlib figure with sliders for manual adjustment
    of rotation (theta) and translation (x, y) to align estimated and ground truth poses.

    Args:
        us_vec: Estimated marker poses (2D numpy array).
        gt_vec: Ground truth marker poses (2D numpy array).
    """

    # Initial values for sliders
    theta = 0.0
    x_translation = 0.0
    y_translation = 0.0

    # adding an origin
    us_vec = np.hstack((us_vec, np.zeros((2, 1))))

    if gt_vec.any():
        gt_vec = np.hstack((gt_vec, np.zeros((2, 1))))

    new_taglist = np.append(taglist, 0)

    # Create the plot
    fig, ax = plt.subplots()
    if gt_vec.any():
        ax.scatter(gt_vec[0, :], gt_vec[1, :], marker='o', color='C0', s=100, label='Ground Truth')
    ax.scatter(us_vec[0, :], us_vec[1, :], marker='x', color='C1', s=100, label='Estimated')
    # for i in range(len(taglist)):
    for i in range(len(new_taglist)):
        if gt_vec.any():
            ax.text(gt_vec[0,i]+0.05, gt_vec[1,i]+0.05, new_taglist[i], color='C0', size=12)
        ax.text(us_vec[0,i]+0.05, us_vec[1,i]+0.05, new_taglist[i], color='C1', size=12)
    plt.title('Marker Alignment')
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.legend()
    plt.grid(True)

    # Define a function to update the plot based on slider values
    def update(val):
        theta = theta_slider.val
        x_translation = x_slider.val
        y_translation = y_slider.val

        x = [[x_translation], [y_translation]]

        # Apply transformation
        us_vec_aligned = apply_transform(theta, x, us_vec.copy())

        # Update plot with transformed estimated poses
        ax.collections[1].set_offsets(us_vec_aligned.T)

        # Clear and redraw text labels to avoid stacking
        for text in ax.texts:
            text.remove()
        for i in range(len(new_taglist)):
            ax.text(gt_vec[0,i]+0.05, gt_vec[1,i]+0.05, new_taglist[i], color='C0', size=12)
            ax.text(us_vec_aligned[0, i] + 0.05, us_vec_aligned[1, i] + 0.05, new_taglist[i], color='C1', size=12)

        fig.canvas.draw_idle()

    # Create sliders
    ax_theta = fig.add_axes([0.24, 0.05, 0.65, 0.01])
    theta_slider = Slider(ax=ax_theta, label='Theta (Rotation)', valmin=-np.pi, valmax=np.pi, valinit=theta, valfmt='%1.3fpi')
    ax_x = fig.add_axes([0.24, 0.025, 0.65, 0.01])
    x_slider = Slider(ax=ax_x, label='X Translation', valmin=-3, valmax=3, valinit=x_translation, valfmt='%1.3f')
    ax_y = fig.add_axes([0.24, 0.0, 0.65, 0.01])
    y_slider = Slider(ax=ax_y, label='Y Translation', valmin=-3, valmax=3, valinit=y_translation, valfmt='%1.3f')

    # Connect sliders to update function
    theta_slider.on_changed(update)
    x_slider.on_changed(update)
    y_slider.on_changed(update)

    # Display the plot
    plt.show()

    # Start the event loop
    plt.ion()

    print(f"Theta: {theta_slider.val:.3f}, X Translation: {x_slider.val:.3f}, Y Translation: {y_slider.val:.3f}")

    theta = theta_slider.val
    x = [[x_slider.val], [y_slider.val]]

    return theta, x




if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser("Matching the estimated map and the true map")
    parser.add_argument("--groundtruth", type=str, help="The ground truth file name.", default='.txt')
    parser.add_argument("--estimate", type=str, help="The estimate file name.", default='lab_output/slam.txt')
    parser.add_argument("--transformed", type=str, help="The transformed file name.", default='lab_output/slam_transformed.txt')
    parser.add_argument("--combined", type=str, help="The combined estimate file name.", default='combined_map.txt')
    # NOTE changed this to parse known
    args, _ = parser.parse_known_args()

    gt_aruco = parse_map(args.groundtruth)
    us_aruco = parse_map(args.estimate)

    taglist, us_vec, gt_vec = match_aruco_points(us_aruco, gt_aruco)
    idx = np.argsort(taglist)
    taglist = np.array(taglist)[idx]
    us_vec = us_vec[:,idx]
    gt_vec = gt_vec[:, idx] 

    # THIS PART IS TECHNICALLY CHEATING LMFAO
    theta, x = solve_umeyama2d(us_vec, gt_vec)
    us_vec_aligned = apply_transform(theta, x, us_vec)
    print(x)
    
    diff = gt_vec - us_vec_aligned
    rmse = compute_rmse(us_vec, gt_vec)
    rmse_aligned = compute_rmse(us_vec_aligned, gt_vec)
    
    print()
    print("The following parameters optimally transform the estimated points to the ground truth.")
    print("Rotation Angle: {}".format(theta))
    print("Translation Vector: ({}, {})".format(x[0,0], x[1,0]))
    
    print()
    print("Number of found markers: {}".format(len(taglist)))
    print("RMSE before alignment: {}".format(rmse))
    print("RMSE after alignment:  {}".format(rmse_aligned))

    print()
    print('%s %7s %9s %7s %11s %9s %7s' % ('Marker', 'Real x', 'Pred x', 'Δx', 'Real y', 'Pred y', 'Δy'))
    print('-----------------------------------------------------------------')
    for i in range(len(taglist)):
        print('%3d %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n' % (taglist[i], gt_vec[0][i], us_vec_aligned[0][i], diff[0][i], gt_vec[1][i], us_vec_aligned[1][i], diff[1][i]))
    

    # show result of slam_eval AS NORMAL  
    ax = plt.gca()
    ax.scatter(gt_vec[0,:], gt_vec[1,:], marker='o', color='C0', s=100)
    ax.scatter(us_vec_aligned[0,:], us_vec_aligned[1,:], marker='x', color='C1', s=100)
    for i in range(len(taglist)):
        ax.text(gt_vec[0,i]+0.05, gt_vec[1,i]+0.05, taglist[i], color='C0', size=12)
        ax.text(us_vec_aligned[0,i]+0.05, us_vec_aligned[1,i]+0.05, taglist[i], color='C1', size=12)
    plt.title('Arena')
    plt.xlabel('X')
    plt.ylabel('Y')
    ax.set_xticks([-1.6, -1.2, -0.8, -0.4, 0, 0.4, 0.8, 1.2, 1.6])
    ax.set_yticks([-1.6, -1.2, -0.8, -0.4, 0, 0.4, 0.8, 1.2, 1.6])
    plt.legend(['Real','Pred'])
    plt.grid()
    plt.show()


    # NOTE me when i make changes
    theta, x = manual_alignment(us_vec, gt_vec)
    us_vec_aligned = apply_transform(theta, x, us_vec)
    print(x)

    diff = gt_vec - us_vec_aligned
    rmse = compute_rmse(us_vec, gt_vec)
    rmse_aligned = compute_rmse(us_vec_aligned, gt_vec)

    print()
    print("The following parameters ARE ACTUALLY USED to transform the estimated points to the ground truth.")
    print("Rotation Angle: {}".format(theta))
    print("Translation Vector: ({}, {})".format(x[0][0], x[1][0]))


    print()
    print("Number of found markers: {}".format(len(taglist)))
    print("RMSE before alignment: {}".format(rmse))
    print("RMSE after alignment:  {}".format(rmse_aligned))

    print()
    print('%s %7s %9s %7s %11s %9s %7s' % ('Marker', 'Real x', 'Pred x', 'Δx', 'Real y', 'Pred y', 'Δy'))
    print('-----------------------------------------------------------------')
    for i in range(len(taglist)):
        print('%3d %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n' % (taglist[i], gt_vec[0][i], us_vec_aligned[0][i], diff[0][i], gt_vec[1][i], us_vec_aligned[1][i], diff[1][i]))
    
    # save these manually transformed points in a file
    save_transformed_points(us_vec_aligned, args.transformed)

    # # map can now combine slam est with fruit ests as a true map that can be read in :)
    # save_map(fname1=args.transformed, fname3=args.combined)



# TODO new
# update: this works, the transformed arucos are saved into a new map 
